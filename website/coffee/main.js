// Generated by CoffeeScript 2.5.1
(function() {
  /*
  Station viewer
  */
  var StationViewer;

  StationViewer = class StationViewer {
    constructor(container) {
      this.showCamera = this.showCamera.bind(this);
      // Places a label as the user hovers over objects
      this.idleMove = this.idleMove.bind(this);
      this.container = container;
    }

    
      // Initialises the container/canvas
    init() {
      var error;
      // Create a clock for timing
      this.clock = new THREE.Clock();
      // Create a camera and controls
      this.camera = new THREE.PerspectiveCamera(20, 1, 0.0001, 10000);
      this.camera.position.set(0, 0, 50);
      this.camera.rotation.set(0, 0, 0);
      this.scene = new THREE.Scene();
      this.scene.add(this.camera);
      this.controls = new TurntableControls(this.camera, new THREE.Vector3(0, 0, 0), this.container[0], this.idleMove, (() => {
        return this.needsRender = true;
      }));
      this.controls.bearing = 0;
      this.controls.angle = Math.PI / 6;
      this.controls.distance = 60;
      this.controls.flipyz = true;
      this.addCompass();
      this.needsRender = false;
      try {
        // Create the WebGL context & renderers
        this.renderer = new THREE.WebGLRenderer({
          antialias: true
        });
        // Default to Canvas for now, as it's better
        this.renderer = new THREE.CanvasRenderer();
        this.webgl = 0;
        jQuery(".webgl-switcher").show().click(() => {
          return this.toggleWebGL();
        });
      } catch (error1) {
        error = error1;
        jQuery(".webgl-error").show();
        this.renderer = new THREE.CanvasRenderer();
        this.webgl = 0;
      }
      this.container.append(this.renderer.domElement);
      // Set up resizing correctly
      this.resizeRenderer();
      window.addEventListener('resize', (() => {
        return this.resizeRenderer();
      }), false);
      // Deal with history management
      return $(window).bind('hashchange', (() => {
        return this.hashChange();
      }));
    }

    // Deals with hash changes
    hashChange() {
      var fragment;
      fragment = $.param.fragment();
      if (fragment === "") {
        return this.showPicker(true);
      } else {
        return this.pickerChoice(fragment);
      }
    }

    // Adds a compass to the world
    addCompass() {
      var loader;
      // Add the gyroscope node
      this.compassRoot = new THREE.Gyroscope();
      this.compassRoot.position.x = -3.5;
      this.compassRoot.position.y = 1.4;
      this.compassRoot.position.z = -10;
      this.camera.add(this.compassRoot);
      // Add a compass model
      loader = new THREE.JSONLoader();
      return loader.load("build/north-arrow.js", ((geom) => {
        this.compass = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({
          color: 0xaa4444
        }));
        this.compass.scale = new THREE.Vector3(0.2, 0.2, 0.2);
        return this.compassRoot.add(this.compass);
      }));
    }

    // Shows/hides the FPS counter
    showFPS() {
      this.stats = new Stats();
      $(this.stats.domElement).css({
        position: "absolute",
        top: "0px"
      });
      return this.container.append(this.stats.domElement);
    }

    // Resizes the main viewport to match the current window
    resizeRenderer() {
      this.renderer.setSize(this.container.width(), this.container.height());
      this.camera.aspect = this.container.width() / this.container.height();
      this.camera.updateProjectionMatrix();
      return this.needsRender = true;
    }

    // Main render loop
    renderLoop() {
      requestAnimationFrame(() => {
        return this.renderLoop();
      });
      this.render(this.clock.getDelta());
      if (this.stats != null) {
        return this.stats.update();
      }
    }

    // Main render function
    render(delta) {
      var volatile;
      TWEEN.update();
      volatile = this.controls.update(delta);
      if (this.needsRender) {
        this.renderer.render(this.scene, this.camera);
      }
      return this.needsRender = false;
    }

    // Loads a station from its URL
    loadSystem(url, callback) {
      return jQuery.getJSON(url, "", (data) => {
        var code, codes, details, j, k, len, len1, li, line, line_color, line_title, picker, ref, ref1;
        // Save the system data to ourselves
        this.system = data;
        this.system.base_url = url.slice(0, url.lastIndexOf("/") + 1);
        // Populate the picker
        picker = jQuery(".picker .stations").html("");
        codes = [];
        ref = this.system.stations;
        for (code in ref) {
          details = ref[code];
          codes.push(code);
        }
        codes.sort();
        for (j = 0, len = codes.length; j < len; j++) {
          code = codes[j];
          details = this.system.stations[code];
          li = jQuery("<li><h5>" + details.title + "</h5><p></p></li>");
          ref1 = details.lines;
          for (k = 0, len1 = ref1.length; k < len1; k++) {
            line = ref1[k];
            line_color = this.system.lines[line].color;
            line_title = this.system.lines[line].title;
            li.find("p").append("<span style='background: #" + line_color + "'>" + line_title + "</span>");
          }
          ((code) => {
            return li.click(() => {
              return this.pickerChoice(code);
            });
          })(code);
          picker.append(li);
        }
        // Possibly run a callback
        if (callback != null) {
          return callback();
        }
      });
    }

    pickerChoice(code) {
      this.loadStation(code);
      this.hidePicker();
      return document.location.href = "#" + code;
    }

    // Toggles between WebGL and Canvas modes
    toggleWebGL() {
      jQuery("canvas").remove();
      if (this.webgl) {
        this.renderer = new THREE.CanvasRenderer();
        this.webgl = 0;
        jQuery(".webgl-switcher").text("Canvas mode - click to use WebGL");
      } else {
        this.renderer = new THREE.WebGLRenderer();
        this.webgl = 1;
        jQuery(".webgl-switcher").text("WebGL mode - click to use Canvas");
      }
      this.container.append(this.renderer.domElement);
      return this.resizeRenderer();
    }

    // Shows the "pick a station" dialog
    showPicker(suppress) {
      jQuery(".picker").show();
      if (suppress !== true) {
        return document.location.href = "#";
      }
    }

    // Hides the picker dialog
    hidePicker() {
      return jQuery(".picker").hide();
    }

    // Loads a station from its URL
    loadStation(code, callback) {
      return jQuery.getJSON(this.system.base_url + this.system.stations[code].meta, "", (data) => {
        var cameraNames, j, k, len, len1, line, line_color, line_title, loader, name, ref, ref1, ref2, ref3, settings, title, value;
        // Save the station data to ourselves
        this.station = data;
        // Load the model
        loader = new THREE.SceneLoader();
        loader.load(this.system.base_url + data['model'], (obj) => {
          return this.ingestScene(obj);
        });
        // Set up the camera stuff
        jQuery(".camera select").empty();
        cameraNames = [];
        ref = this.station.cameras;
        for (name in ref) {
          settings = ref[name];
          cameraNames.push(name);
        }
        cameraNames = cameraNames.sort();
        for (j = 0, len = cameraNames.length; j < len; j++) {
          name = cameraNames[j];
          settings = this.station.cameras[name];
          jQuery(".camera select").append("<option value='" + name + "'>" + ((ref1 = settings.title) != null ? ref1 : name) + "</option>");
        }
        if (cameraNames.length > 1) {
          jQuery(".camera").show();
        } else {
          jQuery(".camera").hide();
        }
        this.showCamera("default");
        // Arrange the page
        jQuery(".header h1").text(data.title);
        jQuery(".header h2").text("");
        ref2 = data.lines;
        for (k = 0, len1 = ref2.length; k < len1; k++) {
          line = ref2[k];
          line_color = this.system.lines[line].color;
          line_title = this.system.lines[line].title;
          jQuery(".header h2").append("<span style='background: #" + line_color + "'>" + line_title + "</span>");
        }
        jQuery(".copyright .value").text(data.info.copyright);
        // Attributes
        jQuery(".info").html("<dl></dl>");
        ref3 = this.system.infos;
        for (name in ref3) {
          title = ref3[name];
          value = data.info[name];
          if (value != null) {
            if (typeof value === "boolean") {
              value = value ? "Yes" : "No";
            }
            jQuery(".info dl").append("<dt>" + title + "</dt>");
            jQuery(".info dl").append("<dd>" + value + "</dd>");
          }
        }
        // Descriptio/notes
        if (data.info.description) {
          jQuery(".info").append("<p>" + data.info.description + "</p>");
        }
        if (data.info.model_notes) {
          jQuery(".info").append("<h2 class='model_notes'>Modeller's Notes</h2><p class='model_notes'>" + data.info.model_notes + "</p>");
        }
        if (callback != null) {
          return callback();
        }
      });
    }

    showCamera(name, speed) {
      var camera, end, pos, ref, ref1, ref2, tween;
      camera = this.station.cameras[name];
      pos = {
        distance: this.controls.distance,
        bearing: this.controls.bearing,
        angle: this.controls.angle,
        x: this.controls.target.x,
        y: this.controls.target.y,
        z: this.controls.target.z
      };
      end = {
        distance: camera.distance,
        bearing: (camera.bearing / 180) * Math.PI,
        angle: (camera.angle / 180) * Math.PI,
        x: -((ref = camera.horizontal) != null ? ref : 0),
        y: (ref1 = camera.elevation) != null ? ref1 : 0,
        z: (ref2 = camera.vertical) != null ? ref2 : 0
      };
      tween = new TWEEN.Tween(pos).to(end, speed != null ? speed : 1);
      tween.onUpdate(() => {
        this.controls.distance = pos.distance;
        this.controls.bearing = pos.bearing;
        this.controls.angle = pos.angle;
        this.controls.target.x = pos.x;
        this.controls.target.y = pos.y;
        this.controls.target.z = pos.z;
        return this.needsRender = true;
      });
      tween.easing(TWEEN.Easing.Quadratic.EaseInOut).start();
      return jQuery(".camera select").val(name);
    }

    // Takes a SceneLoader result and places it in the world
    ingestScene(scene) {
      var geometry, grid_size, grid_step, grid_steps, i, item, j, line, material, material_def, name, ref, ref1, ref2, ref3;
      this.cleanWorld();
      this.root = new THREE.Object3D();
      ref = scene.objects;
      for (name in ref) {
        item = ref[name];
        material_def = this.system.materials[name.slice(0, name.indexOf("."))];
        material = new THREE.MeshLambertMaterial({
          color: eval("0x" + (material_def ? material_def.color : "000000")),
          shading: THREE.FlatShading,
          opacity: 0.9
        });
        item.material = material;
        item.doubleSided = true;
        this.root.add(item);
      }
      this.root.rotation.x = -Math.PI / 2;
      this.root.rotation.z = Math.PI;
      this.scene.add(this.root);
      // Draw the grid
      grid_size = this.station.environment.grid;
      grid_step = 5;
      grid_steps = grid_size / grid_step;
      material = new THREE.LineBasicMaterial({
        color: 0x000000,
        opacity: 0.05,
        linewidth: 1
      });
      geometry = new THREE.Geometry();
      geometry.vertices.push(new THREE.Vertex(new THREE.Vector3(-grid_size, 0, 0)));
      geometry.vertices.push(new THREE.Vertex(new THREE.Vector3(grid_size, 0, 0)));
      for (i = j = ref1 = -grid_steps, ref2 = grid_steps; (ref1 <= ref2 ? j <= ref2 : j >= ref2); i = ref1 <= ref2 ? ++j : --j) {
        line = new THREE.Line(geometry, material);
        line.position.z = i * grid_step;
        this.scene.add(line);
        line = new THREE.Line(geometry, material);
        line.rotation.y = Math.PI / 2;
        line.position.x = i * grid_step;
        this.scene.add(line);
      }
      this.needsRender = true;
      // Align the compass
      return this.compass.rotation.y = (Math.PI * (180 + ((ref3 = this.station.environment.north) != null ? ref3 : 0))) / 180;
    }

    // Prepares a nice, clean Scene to put things in
    cleanWorld() {
      var light;
      this.scene = new THREE.Scene();
      // Lights
      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(-3, 2, 1);
      light.position.normalize();
      light.intensity = 1.1;
      this.scene.add(light);
      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(3, 2, -1);
      light.position.normalize();
      light.intensity = 0.8;
      this.scene.add(light);
      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(3, -2, -1);
      light.position.normalize();
      light.intensity = 0.5;
      this.scene.add(light);
      //light = new THREE.AmbientLight(0x888888)
      //@scene.add(light)
      // Camera
      return this.scene.add(this.camera);
    }

    idleMove(event) {
      var details, name, object, text, title, tooltip, x, y;
      if (this.root == null) {
        return;
      }
      x = event.offsetX;
      y = event.offsetY;
      if (!((x != null) && (y != null))) {
        x = event.layerX;
        y = event.layerY;
      }
      object = this.underPixel(x, y);
      if (object != null) {
        name = object.name;
        if (name.indexOf(".") !== name.lastIndexOf(".")) {
          name = name.slice(0, name.lastIndexOf("."));
        }
        details = this.station.objects[name];
        if (details != null) {
          title = details.title;
          text = details.text != null ? details.text : "";
          if (text) {
            tooltip = "<h6>" + title + "</h6><p>" + text + "</p>";
          } else {
            tooltip = "<h6>" + title + "</h6>";
          }
          return jQuery(".tooltip").html(tooltip).show().css({
            top: y,
            left: x + 15
          });
        } else {
          return jQuery(".tooltip").hide();
        }
      } else {
        return jQuery(".tooltip").hide();
      }
    }

    // Given a pixel position on the drawing area, says what's under it
    underPixel(x, y) {
      var hit, intersects, projector, ray, vector;
      vector = new THREE.Vector3((x / this.container.width()) * 2 - 1, -(y / this.container.height()) * 2 + 1, 0.5);
      projector = new THREE.Projector();
      projector.unprojectVector(vector, this.camera);
      ray = new THREE.Ray(this.camera.position, vector.subSelf(this.camera.position).normalize());
      intersects = ray.intersectObjects(this.root.children);
      if (intersects.length > 0) {
        hit = intersects[0];
        return hit.object;
      }
      return null;
    }

  };

  window.StationViewer = StationViewer;

}).call(this);
